# exp1-1 手动构造NFA与NFA的序列化

实现程序，输入所有边的信息，输出该NFA的序列化结果

## 输入

每行格式为`<prev> <symbol> <next>`，比如`0 a 1`，表明从节点0到节点1有一条边，边的字符为`a`

输入不保证没有重边，对于输入中的重边应当去重处理

输入中第一行的`<prev>`节点保证为0并应视作NFA的起点，最后一行的`<next>`节点保证数字最大且视作NFA的终点

## 输出

该NFA的序列化结果。其格式为`[<NodeInfo1>, <NodeInfo2>, ..., <NodeInfoN>]`

`<NodeInfoN>`代表了第N个节点的信息。其格式为`(n, [<Edges1>, <Edges2>, ..., <EdgesN>])`，其中n为节点编号

`<EdgesN>`代表了某节点直接经过某字符后可到达的所有节点。其格式为`(<symbol>, [n1, n2, ..., nM])`

## 示例

1.
    输入
    ```
    0 a 1
    ```
    输出
    ```
    [(0,[(a,[1])])]
    ```
2.
    输入
    ```
    0 a 1
    0 a 2
    ```
    输出
    ```
    [(0,[(a,[1,2])])]
    ```
3.
    输入
    ```
    0 a 1
    0 b 2
    ```
    输出
    ```
    [(0,[(a,[1]),(b,[2])])]
    ```
4.
    输入
    ```
    0 a 1
    1 b 2
    ```
    输出
    ```
    [(0,[(a,[1])]),(1,[(b,[2])])]
    ```
5.
    输入
    ```
    0 _ 1
    ```
    输出
    ```
    [(0,[(_,[1])])]
    ```