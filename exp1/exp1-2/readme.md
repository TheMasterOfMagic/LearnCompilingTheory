# exp1-2 NFA的反序列化及and、or与closure运算

为避免编号不统一带来的计算结果不统一，特规定如下：
记nfa1、nfa2分别为两个NFA，其节点编号分别为0到n1与0到n2。规定：
- 计算`nfa1 and nfa2`时，将nfa2的节点重新编号为n1到n1+n2，并合并它们的n1节点（即合并nfa1的终点与新nfa2的起点）
- 计算`nfa1 or nfa2`时，将nfa1的节点重新编号为1到n1+1，将nfa2的节点重新编号为n1+2到n1+n2+2，同时规定结果中起点编号为0，终点编号为n1+n2+3
- 计算`closure nfa1`时，将nfa1的节点重新编号为1到n1+1，同时规定结果中起点编号为0，终点编号为n1+2

## 输入

两行，分别为nfa1与nfa2的序列化结果

## 输出

三行，分别为上述三种运算符对应的结果

## 示例

1.
    输入
    ```
    [(0,[(a,[1])])]
    [(0,[(b,[1])])]
    ```
    输出
    ```
    [(0,[(a,[1])]),(1,[(b,[2])])]
    [(0,[(_,[1,3])]),(1,[(a,[2])]),(2,[(_,[5])]),(3,[(b,[4])]),(4,[(_,[5])])]
    [(0,[(_,[1,3])]),(1,[(a,[2])]),(2,[(_,[1,3])])]
    ```